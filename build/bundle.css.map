{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../Channels.svelte",
    "../../Messages.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { createEventDispatcher } from 'svelte';\n  import { flick } from '../utils';\n\n  const dispatch = createEventDispatcher();\n\n  // Generate a list of channels for the UI\n  const channels = Array(10).fill(0, 0, 10).map((_, i) => ({\n    name: `channel_${i + 1}`,\n    unread: i < 4\n  }));\n\n  // Get the unread channels\n  const unread = channels.filter(channel => channel.unread);\n\n  export let channelsSwipingEvent; // `swiping` event on this (channels) screen\n  export let messagesSwipingEvent; // `swiping` event on the messages screen\n  export let active = false; // Is this the currently active screen?\n\n  /**\n   * Returns the styles to be applied\n   * @param {Event} channelsSwipingEvent `swiping` event on this screen\n   * @param {Event} messagesSwipingEvent `swiping` event on the messages screen\n   * \n   * @returns {Object|undefined}\n   *  @prop {string} main Styles for the main element\n   *  @prop {string} overlay Styles for the overlay\n   */\n  function getSwipeStyle (channelsSwipingEvent, messagesSwipingEvent) {\n    if (channelsSwipingEvent) {\n      // User is swiping on the Channels screen\n      \n      const { detail } = channelsSwipingEvent;\n      const { x } = detail;\n\n      if (!x) {\n        return;\n      }\n\n      const distance = x[0] - x[1];\n\n      if (distance < 0) {\n        // Swipe is in opposite direction\n        // We don't want to trigger anything in the UI on the Channels screen\n        return;\n      }\n\n      // Figure out how much do we need to push the screen to left\n      // Also figure out the opacity\n      const perc = distance * 20 / window.screen.width;\n\n      // Disabling transitions because we want the repositioning to happen instantly\n\n      return {\n        main: `transform: translateX(-${perc}%); transition: none;`,\n        overlay: `opacity: ${(perc / 50)}; transition: none;`,\n      }\n    } else if (messagesSwipingEvent) {\n      // User is swiping on the Messages screen\n\n      const { detail } = messagesSwipingEvent;\n      const { x } = detail;\n\n      if (!x) {\n        return;\n      }\n\n      const distance = x[1] - x[0];\n\n      if (distance < 0) {\n        // Swipe is in opposite direction\n        // We don't want to trigger anything in the UI on the Channels screen\n        return;\n      }\n\n      // Figure out how much do we need to push the screen to right\n      // Also figure out the opacity\n      const perc = distance * 20 / window.screen.width;\n\n      // Disabling transitions because we want the repositioning to happen instantly\n\n      return {\n        main: `transform: translateX(-${20 - perc}%); transition: none;`,\n        overlay: `opacity: ${0.5 - (perc / 50)}; transition: none;`,\n      };\n    }\n\n    return {\n      main: '',\n      overlay: '',\n    };\n  }\n\n  const initStyles = { main: '', overlay: '' }; // Initial styles for the main element and overlay\n\n  // Styles that make the UI feel like it is being swiped on\n  let swipeStyle = initStyles;\n  \n  /**\n   * When `channelsSwipingEvent` or `messagesSwipingEvent` change,\n   * try to calculate the new styles.\n   * Fall back to `initStyles` on failure.\n   */\n  $: swipeStyle = getSwipeStyle(channelsSwipingEvent, messagesSwipingEvent) || initStyles;\n</script>\n\n<style>\n  h3 {\n    font-size: 0.8rem;\n  }\n\n  .channels + .channels {\n    margin-top: 2em;\n  }\n\n  .channel::first-letter {\n    margin-left: 12px;\n  }\n\n  .channel.unread {\n    font-weight: bold;;\n  }\n\n  .channel + .channel {\n    margin-top: 0.8rem;\n  }\n\n  .inactive {\n    transform: translateX(-20%);\n  }\n\n  .overlay {\n    background-color: black;\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    pointer-events: none;\n\n    opacity: 0;\n  }\n\n  .inactive .overlay {\n    opacity: 0.5;\n  }\n</style>\n\n<div\n  class=\"screen\"\n  class:inactive={!active} \n  \n  style={swipeStyle.main}\n\n  use:flick={{\n    direction: 'left'\n  }}\n\n  on:flick\n  on:swiping\n  on:swiperelease\n>\n  <div class=\"channels\">\n    <h3>Unread channels</h3>\n    {#each unread as channel}\n      <div\n        class=\"channel unread\"\n        on:click={() => dispatch('selectchannel')}>\n        #{channel.name}\n      </div>\n    {/each}\n  </div>\n  <div class=\"channels\">\n    <h3>All channels</h3>\n    {#each channels as channel}\n      <div\n        class=\"channel\"\n        on:click={() => dispatch('selectchannel')}>\n        #{channel.name}\n      </div>\n    {/each}\n  </div>\n  <div class=\"overlay\" style={swipeStyle.overlay}></div>\n</div>",
    "<script>\n  import { flick } from '../utils';\n\n  export let messagesSwipingEvent; // `swiping` event on this (messages) screen\n  export let channelsSwipingEvent; // `swiping` event on the channels screen\n  export let active = false; // Is this the currently active screen?\n\n  /**\n   * Returns the styles to be applied\n   * @param {Event} messagesSwipingEvent `swiping` event on this screen\n   * @param {Event} channelsSwipingEvent `swiping` event on the channels screen\n   * \n   * @returns {string|undefined} Styles for the main element\n   */\n  function getSwipeStyle (messagesSwipingEvent, channelsSwipingEvent) {\n    if (messagesSwipingEvent) {\n      // User is swiping on the Messages screen\n\n      const { detail } = messagesSwipingEvent;\n      const { x } = detail;\n\n      if (!x) {\n        return;\n      }\n\n      const distance = x[1] - x[0];\n\n      if (distance < 0) {\n        // Swipe is in opposite direction\n        // We don't want to trigger anything in the UI on the Messages screen\n        return;\n      }\n\n      // We'll just move the Messages screen as much to the left as the swipe distance\n      const perc = distance * 100 / window.screen.width;\n\n      // Disabling transitions because we want the repositioning to happen instantly\n\n      return `transform: translateX(${perc}%); transition: none;`;\n    } else if (channelsSwipingEvent) {\n      // User is swiping on the Channels screen\n\n      const { detail } = channelsSwipingEvent;\n      const { x } = detail;\n\n      if (!x) {\n        return;\n      }\n\n      const distance = x[0] - x[1];\n\n      if (distance < 0) {\n        // Swipe is in opposite direction\n        // We don't want to trigger anything in the UI on the Messages screen\n        return;\n      }\n\n      // We'll move the messages screen as much into the view from the right as the swipe distance\n      const perc = distance * 100 / window.screen.width;\n\n      // Disabling transitions because we want the repositioning to happen instantly\n\n      return `transform: translateX(${100 - perc}%); transition: none;`;\n    }\n\n    return '';\n  }\n\n  const initStyles = ''; // Initial styles for the main element\n\n  // Styles that make the UI feel like it is being swiped on\n  let swipeStyle = initStyles;\n\n  /**\n   * When `messagesSwipingEvent` or `channelsSwipingEvent` change,\n   * try to calculate the new styles.\n   * Fall back to `initStyles` on failure.\n   */\n  $: swipeStyle = getSwipeStyle(messagesSwipingEvent, channelsSwipingEvent) || initStyles;\n</script>\n\n<style>\n  .inactive {\n    transform: translateX(100%);\n  }\n</style>\n\n<div\n  class=\"screen\"\n  class:inactive={!active}\n  \n  style={swipeStyle}\n  \n  use:flick={{\n    direction: 'right'\n  }}\n\n  on:flick\n  on:swiping\n  on:swiperelease\n  >\n  <h3>Messages</h3>\n</div>"
  ],
  "names": [],
  "mappings": "AA2GE,EAAE,8BAAC,CAAC,AACF,SAAS,CAAE,MAAM,AACnB,CAAC,AAED,SAAS,CAAG,SAAS,8BAAC,CAAC,AACrB,UAAU,CAAE,GAAG,AACjB,CAAC,AAED,sCAAQ,cAAc,AAAC,CAAC,AACtB,WAAW,CAAE,IAAI,AACnB,CAAC,AAED,QAAQ,OAAO,8BAAC,CAAC,AACf,WAAW,CAAE,IAAI,AACnB,CAAC,AAED,QAAQ,CAAG,QAAQ,8BAAC,CAAC,AACnB,UAAU,CAAE,MAAM,AACpB,CAAC,AAED,SAAS,8BAAC,CAAC,AACT,SAAS,CAAE,WAAW,IAAI,CAAC,AAC7B,CAAC,AAED,QAAQ,8BAAC,CAAC,AACR,gBAAgB,CAAE,KAAK,CACvB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,cAAc,CAAE,IAAI,CAEpB,OAAO,CAAE,CAAC,AACZ,CAAC,AAED,wBAAS,CAAC,QAAQ,eAAC,CAAC,AAClB,OAAO,CAAE,GAAG,AACd,CAAC;AC/DD,SAAS,eAAC,CAAC,AACT,SAAS,CAAE,WAAW,IAAI,CAAC,AAC7B,CAAC"
}